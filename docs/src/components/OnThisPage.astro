---
interface Heading {
  depth: number;
  slug: string;
  text: string;
}

interface Props {
  headings: Heading[];
}

const { headings } = Astro.props;

const filteredHeadings = headings.filter((h) => h.depth >= 2 && h.depth <= 3);
---

{filteredHeadings.length > 0 && (
  <nav class="on-this-page" aria-label="On this page">
    <h2 class="toc-header text-xs font-semibold uppercase tracking-[0.2em] text-text-subtle mb-4">
      On this page
    </h2>
    <div class="toc-wrapper">
      <div class="toc-track">
        <div class="toc-progress" id="toc-progress"></div>
        <div class="toc-viewport" id="toc-viewport"></div>
      </div>
      <ul class="toc-list space-y-1 text-sm">
        {filteredHeadings.map((heading, headingIndex) => (
          <li class:list={["toc-item", heading.depth === 3 && "toc-item-nested"]}>
            <a
              href={`#${heading.slug}`}
              class="toc-link block text-text-muted transition-all duration-200 py-2"
              data-heading-slug={heading.slug}
              data-index={headingIndex}
            >
              {heading.text}
            </a>
          </li>
        ))}
      </ul>
    </div>
  </nav>
)}

<script>
  const initializeToc = () => {
    const headings = Array.from(document.querySelectorAll("h2[id], h3[id]"));
    const tocLinks = Array.from(document.querySelectorAll(".toc-link"));
    const tocProgress = document.getElementById("toc-progress");
    const tocViewport = document.getElementById("toc-viewport");
    const tocList = document.querySelector(".toc-list");

    if (headings.length === 0 || tocLinks.length === 0 || !tocList) {
      return;
    }

    let activeHeadingIndex = 0;
    let headingOffsets = headings.map((heading) => (heading as HTMLElement).offsetTop);
    let isUserNavigating = false;
    let navigationTimeoutId: number | undefined;

    const findScrollContainer = (element: HTMLElement) => {
      let currentElement = element.parentElement;

      while (currentElement) {
        const computedStyle = window.getComputedStyle(currentElement);
        const overflowY = computedStyle.overflowY;

        if (overflowY === "auto" || overflowY === "scroll") {
          return currentElement;
        }

        currentElement = currentElement.parentElement;
      }

      return null;
    };

    const scrollContainer = findScrollContainer(tocList as HTMLElement);

    const updateMeasurements = () => {
      headingOffsets = headings.map((heading) => (heading as HTMLElement).offsetTop);
    };

    const beginUserNavigation = (targetIndex: number) => {
      isUserNavigating = true;
      if (navigationTimeoutId) {
        window.clearTimeout(navigationTimeoutId);
      }

      activeHeadingIndex = targetIndex;
      updateLinkStates();
      updateViewportIndicator();

      navigationTimeoutId = window.setTimeout(() => {
        isUserNavigating = false;
        navigationTimeoutId = undefined;
      }, 800);
    };

    const updateProgress = () => {
      if (!tocProgress) {
        return;
      }

      const documentHeight = document.documentElement.scrollHeight;
      const windowHeight = window.innerHeight;
      const scrollableHeight = Math.max(documentHeight - windowHeight, 1);
      const scrollProgress = Math.min(window.scrollY / scrollableHeight, 1);

      tocProgress.style.height = `${scrollProgress * 100}%`;
    };

    const updateViewportIndicator = () => {
      if (!tocViewport) {
        return;
      }

      const activeLink = tocLinks[activeHeadingIndex] as HTMLElement | undefined;
      if (!activeLink) {
        return;
      }

      const listRect = tocList.getBoundingClientRect();
      const linkRect = activeLink.getBoundingClientRect();
      const offsetTop = linkRect.top - listRect.top;

      tocViewport.style.top = `${offsetTop}px`;
      tocViewport.style.height = `${linkRect.height}px`;

      if (!scrollContainer || scrollContainer.scrollHeight <= scrollContainer.clientHeight) {
        return;
      }

      if (isUserNavigating) {
        return;
      }

      const scrollContainerRect = scrollContainer.getBoundingClientRect();
      const scrollTop = scrollContainer.scrollTop;
      const linkCenter = linkRect.top - scrollContainerRect.top + scrollTop + linkRect.height / 2;
      const targetCenter = scrollTop + scrollContainer.clientHeight * 0.5;
      const offsetDelta = linkCenter - targetCenter;

      if (Math.abs(offsetDelta) < 1) {
        return;
      }

      const maxScrollTop = scrollContainer.scrollHeight - scrollContainer.clientHeight;
      const nextScrollTop = Math.min(maxScrollTop, Math.max(0, scrollTop + offsetDelta));

      scrollContainer.scrollTo({
        top: nextScrollTop,
        behavior: "smooth",
      });
    };

    const updateLinkStates = () => {
      tocLinks.forEach((link, linkIndex) => {
        link.classList.remove("is-active", "is-passed");

        if (linkIndex === activeHeadingIndex) {
          link.classList.add("is-active");
        } else if (linkIndex < activeHeadingIndex) {
          link.classList.add("is-passed");
        }
      });
    };

    const setActiveHeadingIndex = (nextIndex: number) => {
      if (isUserNavigating || nextIndex === activeHeadingIndex) {
        return;
      }

      activeHeadingIndex = nextIndex;
      updateLinkStates();
      updateViewportIndicator();
    };

    const fallbackActiveHeading = () => {
      const offset = 100;
      const currentScroll = window.scrollY;
      const documentHeight = document.documentElement.scrollHeight;
      const windowHeight = window.innerHeight;
      const isNearBottom = currentScroll + windowHeight >= documentHeight - 80;

      if (isNearBottom) {
        setActiveHeadingIndex(headings.length - 1);
        return;
      }

      let nextIndex = 0;
      headingOffsets.forEach((headingOffset, headingIndex) => {
        if (currentScroll >= headingOffset - offset) {
          nextIndex = headingIndex;
        }
      });

      setActiveHeadingIndex(nextIndex);
    };

    const observer = new IntersectionObserver(
      (entries) => {
        const visibleEntries = entries
          .filter((entry) => entry.isIntersecting)
          .sort((firstEntry, secondEntry) => firstEntry.boundingClientRect.top - secondEntry.boundingClientRect.top);

        if (visibleEntries.length === 0) {
          fallbackActiveHeading();
          return;
        }

        const targetHeading = visibleEntries[0]?.target as HTMLElement | undefined;
        if (!targetHeading) {
          return;
        }

        const nextIndex = headings.findIndex((heading) => heading === targetHeading);
        if (nextIndex >= 0) {
          setActiveHeadingIndex(nextIndex);
        }
      },
      {
        rootMargin: "-20% 0px -65% 0px",
        threshold: [0, 0.5, 1],
      }
    );

    headings.forEach((heading) => observer.observe(heading));

    tocLinks.forEach((link, linkIndex) => {
      link.addEventListener("click", () => {
        beginUserNavigation(linkIndex);
      });
    });

    updateMeasurements();
    updateProgress();
    updateLinkStates();
    updateViewportIndicator();

    let isTicking = false;
    window.addEventListener("scroll", () => {
      if (isTicking) {
        return;
      }

      window.requestAnimationFrame(() => {
        updateProgress();
        fallbackActiveHeading();
        isTicking = false;
      });

      isTicking = true;
    });

    window.addEventListener("resize", () => {
      updateMeasurements();
      updateViewportIndicator();
      updateProgress();
      fallbackActiveHeading();
    });
  };

  initializeToc();
</script>

<style>
  .toc-wrapper {
    position: relative;
    padding-left: 16px;
  }

  .toc-track {
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 2px;
  }

  .toc-track::before {
    content: "";
    position: absolute;
    left: 0.5px;
    top: 0;
    bottom: 0;
    width: 1px;
    background: var(--color-border);
    border-radius: 999px;
  }

  .toc-progress {
    position: absolute;
    left: 0.5px;
    top: 0;
    width: 1px;
    height: 0;
    background: var(--color-brand-muted);
    border-radius: 999px;
    transition: height 0.2s ease;
  }

  .toc-viewport {
    position: absolute;
    left: 0;
    top: 0;
    width: 2px;
    height: 16px;
    background: var(--color-brand);
    border-radius: 999px;
    box-shadow: var(--glow-brand-subtle);
    transition: top 0.2s ease, height 0.2s ease;
  }

  .toc-list {
    position: relative;
  }

  .toc-item-nested .toc-link {
    padding-left: 18px;
    font-size: 0.875rem;
  }

  .toc-link {
    position: relative;
    padding-left: 12px;
    color: var(--color-text-muted);
    transition: color 0.2s ease, transform 0.2s ease;
  }

  .toc-link::before {
    content: "";
    position: absolute;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 2px;
    height: 0;
    background: var(--color-brand);
    border-radius: 999px;
    opacity: 0;
    transition: height 0.2s ease, opacity 0.2s ease;
  }

  .toc-link:hover {
    color: var(--color-text);
    transform: translateX(1px);
  }

  .toc-link.is-active {
    color: var(--color-brand);
    font-weight: 500;
    text-shadow: 0 0 20px rgba(87, 109, 220, 0.35);
  }

  .toc-link.is-active::before {
    height: 14px;
    opacity: 1;
    box-shadow: var(--glow-brand-subtle);
  }

  .toc-link.is-passed {
    color: var(--color-text-subtle);
  }
</style>
